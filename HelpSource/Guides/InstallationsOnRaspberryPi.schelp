TITLE::Deploying an Installation on a Raspberry Pi
categories:: Control
related:: Classes/Installation, Classes/WatchDog, Guides/KeepAnInstallationRunning
summary:: How to deploy an installation on a small computer, like a Raspberry Pi

section:: Introduction

Start with link::Guides/KeepAnInstallationRunning::. The Pi is much the same, except everything will crash at some point.

This guide should work with any version of superCollider at 3.6 or later. This is written for Raspbian Wheezy but should work with other versions of Raspbian. It will not work with other Pi operating systems, such as windows, without substantial modifications, especially to the Bash Script

There are a few important differences between running an installation on a laptop and on a Pi.
list::
## The Pi has fewer resources and crashes much more often and in more ways.
## The SC server can be started separately from sclang
## Backing up a Pi system is just duplicating an SD card, so anything weird or dangerous you do is much less risky than it would be on your laptop
::

SuperCollider should run on any Pi.  In practice, the Pi 1 may have trouble coping with anything remotely complex.  The 2 and 3 are able to do much more.

section:: Getting the Pi Ready

Are you planning on attaching a monitor to the Pi? If so, you will want to tell to boot to the desktop. Otherwise, you want to boot to a command line. You can set these options by running code::sudo raspi-config::. If you are not using graphics, you should definitely boot to the command line. The Pi does not have a lot of processor power and if you're not using the Desktop, you can save some space for installation to run.

The headphone jack on Raspberry Pis is extremely low quality.  There is an audio 'hat' available, but it does not work with jack.  To get reasonable sound you will eihter need to get a small USB stick audio card or else use the HDMI audio output.  Nicer USB sound cards may also work, but it's impossible to know without testing.

The version of SuperCollider that ships with Raspbian has often been old or broken and therefore, you may have to build SuperCollider yourself. This is time consuming, but easy.  Once you have built it once, you can make an image of the SD card, zip it and save it. Then, if you need a second copy, you can just write it to a new SD card.  For more on how to build, see link:: https://supercollider.github.io/development/building-raspberrypi.html::

section:: Getting your code ready - Efficiency

SC 3.6 on a Pi runs exactly the same code as SC 3.6 on my laptop. Therefore, installation-ready code should run fine on a Pi. There is less memory on a Pi, which may limit the number of Buffers you can have loaded at one time. I have not experienced any issues with running out of memory. The processor, however, does climb to 100% quite easily and this can lead to audio stuttering. Your synthdefs and invocation should be as efficient as possible. If you always fire off three synths at the same time, say, each with a different frequency, you may want to combine them into one single synthdef that takes three frequency arguments. Starting off one more complicated synthdef requires fewer resources than three simpler synthdefs running at the same time.

If you are running the the desktop, you can see how much of the CPU is being used by looking at the monitor box in the upper right hand corner of the screen. If you are running headless and have connected to the Pi via ssh, you can monitor the CPU using the command 'top'. Open a second terminal window, connect to the Pi and type in top -u pi at the command line. The program will tell you the computer's load average and how much of the CPU each program is using.

Within SuperCollider, to find out how much CPU the server is using, Server.default.avgCPU returns a number between 0 and 100. I've used this information to help calculate how many steps to use for a fade in the graphics. A busier CPU means I fade in fewer steps with longer pauses between steps.

section:: Pi specific sections of bash scripts

The BASH scripts generated by code::Installation.wizard:: can have Pi-specific sections:
code::
if [ $raspberry -eq 1 ]
	then
		# Do Pi stuff
	else
		# Not a Pi
fi
::
One feature of the Pi is that your scripts have the power to rebot the computer, something you may wish to take advantage of, as a rebooted computer is in a known, stable state.

subsection:: Jack

When won't start, of course, the server won't start. So it's helpful to be able to reboot if Jack is refusing to comply.

First, you'll need to determine what your Jack command line should look like, which is outside the scope of this document.

But let's say you want to use jack to access the stereo outputs of a USB audio device:
code::
if [ $raspberry -eq 1 ]
	then
		# Do Pi stuff

		# start jackd
        ( jackd -T -p 32 -d alsa -d hw:0,0 -r 44100 -p 1024 -n3  -s || sudo shutdown -r now ) &

		sleep 10 # wait for jack to settle down
fi
::

If jack fails to start, the computer reboots.


subsection:: Starting the server separately

You may also find it advantageous to try to start the SuperCollider Server from bash rather than within SuperCollider. One fature of this is that your code will be unchanged.

The disadvantage is that because the Server isn't started within SuperCollider, it can't be stopped or rebooted within SuperCollider. A Server crash threrfore necesseitates restarting all of sclang.

If your Pi has a tednecy towards crashes where the server can't be booted, you may find this helpful.

Here is a script that makes multiple tries to get the server going, to test for a condition where the server starts, but then dies very quickly

code::
if [ $raspberry -eq 1 ]
	then
		# Do Pi stuff

		# start jackd
        ( jackd -T -p 32 -d alsa -d hw:0,0 -r 44100 -p 1024 -n3  -s || sudo shutdown -r now ) &

		sleep 10 # wait for jack to settle down

		scsynth -u $port &
        server=$!
        sleep 1

        # is the server running?
        if kill -0 $server  2> /dev/null # This tests if it's running
            then
                #all good
                echo "started"
            else
                # try again

                sleep 5
                port=$(( $port + 1 ))
                scsynth -u $port &
                server=$!

                sleep 1

                # is the server running?
                if kill -0 $server  2> /dev/null
                    then
                        #all good
                        echo "started"
                    else
                        sudo shutdown -r now
                fi
        fi

        sleep 5

        # is the server still running?
        if kill -0 $server  2> /dev/null
            then
                #all good
                echo "still going"
            else
                sudo shutdown -r now
        fi
fi
::

In that example, we try to start jack up again and run it in the background. If it does not start, we reboot the computer. The default user on a Pi is called 'pi'. By default, that user can sudo without entering a password. We are taking advantage of that to make the system reboot. On a normal computer, it would be risky to leave an installation running that could get superuser privileges so easily. However, the Pi's system is just an SD card, which hopefully we have a spare copy of. If something goes horribly wrong, we can just pop in a new card.

We will configure the Pi so the script runs on startup. This means if the computer reboots, the installation will restart.

Then we wait 10 seconds for jack to settle down.

We then increment the port number. In my testing, many crashes are caused by the server crashing. When it crashes, it may not let go of the port it was using. By incrementing every time, we are less likely to have trouble starting the server.

Then we start the server, wait 1 second and check if it's running. If it's not running, we wait 5 seconds, increment the port and try again. If the second attempt fails, we reboot.

Then we wait five more seconds and check AGAIN if the server is running. This may seem like overkill, but, unfortunately, the system can get into a state where a server will start, but then crash about 2 seconds later. By waiting five seconds, we can make sure the server will actually stay started. If not, we reboot.

Then we can go on to the non-pi specific parets of the script.

subsection:: Helper Scripts

If you find that your helper script is taking up too much of the CPU and making your audio glitch, you can change the priority of the script by putting code::nice:: in front of it. check out the manpage of nice for more detail.

section::Debugging

In our bash script above, we've got a lot of reboots. This is how the script will look when we deploy it, but not how it should be early in the testing process. We instead want to run the script ourselves, from the command line, so we can see what is being printed out in the way of error codes or from printlns in SuperCollider. Therefore, when first trying this, we would replace all of our 'sudo shutdown -r now' lines with 'exit'. We may need to reboot anyway when the program stops, but this will give a chance to try to read what went wrong. This can also tell us that, say, the server never wants to start, which may indicate that we have not slept for long enough after starting jack.

To launch a script form the command line, cd to the directory that its in and type: ./YourInstallation.sh (Using the actual name of your file). The ./ at the beginning of the command just says that the script is local to the directory that we're in.

Once the script and program are fairly stable, though, we will want to just leave the installation running, to see if it gets stuck in a state where it stops without restarting or rebooting. When we're ready to do that, we will put the shutdown commands back in and that's when we have the script autostart.

When you've autostarted your program, it runs silently. How can you tell what's going on? It may be helpful to just know what's running at any given time. You can do that via the desktop by running the Task Manager. Or you can to do it from the command line by running top -u pi. This will keep us current on what is running on the system. Is your helper app still going? Is scsynth dying every 10 seconds, causing an endless loop of crashes? Is everything starting when it should and staying alive long enough? This also tells you what is using up the most CPU resources. Does your helper app climb up to 100% before the server crashes?

If you are getting weird crashes that you didn't get when developing the code on your own computer, then one possible problem is the pi version of your startup script. Make a copy of the script and change it so that it always runs as if you are on a Pi. Try it on your own computer (changing the paths as appropriate). Maybe the logic got slightly screwed up.

Maybe your helper script is too nice and the output isn't ready when sclang needs it? Because the Pi has such low power, your program will need to be able to deal with late data. Changing nice values may not be enough to solve this problem. You will need to make sure your SuperCollider program can cope with data arriving late.

Or maybe your helper script isn't nice enough. If it's always at the top in top, it might not be leaving enough space for your server to run. If the server can't get enough CPU, the audio will sound weird and fragmented and the server will crash. This leads to a lot of waiting for everything to restart itself! If you are tending to be using a high percentage of the CPU, scsynth needs to be getting its share of that.

Does your program start out ok, but then seem to always need to reboot in order to recover from a crash? Try making it sleep longer at the end of the loop. Sleeping for several extra seconds in between restarting jack, ssynth and sclang may seem like a long wait between running things, but it's a shorter wait than a reboot.

section::the aesthetic of glitch

You may want to create a long, lush drone that has a relatively simple synthdef, which just starts and runs without getting messages from sclang. That's not going to crash very often. You will have tons of uptime. Give it a try and see if the Pi will work for you.

Or you might want to start a ton of short, complex synths that rely on doing strange calculations, where the possibility of failure is inherent in the process.  That will definitely crash (especially on a Pi 1). There will be long silences while the installation sorts itself out. Therefore, this needs to be a part of your aesthetic that you deal with using some sort of intentionality. You might want to consider having sudden stops and pauses happen when your piece is not crashed, so that a crash just seems like a longer pause. If your piece is using the desktop to do any kind of graphics, set a background image that works within the context of someone experiencing your piece. When the system reboots, people will see that background image, so it should be approached as a part of the installation.

Your audience needs to be prepared for pauses. Foreshadowing in the output is an important part of this, but my last bit of advice is to put something in the program notes, so a person approaching the installation knows it sometimes takes short breaks and may be willing to wait a few minutes if they happen to walk up as it is crashing in a way that will require a reboot.

section::Conclusion

This document has mostly spoken about the disadvantages of the Pi, sometimes at great length. However, if you are reading this while considering running an installation on the Pi, do not despair. The advantages of the Pi may still be greater than the disadvantages.

list::
## It is still small and cheap, thus making it ideal for installations (and for shipping in the post).
## It has a certain coolness factor, which may make venues more interested in your work.
## An SD card is a stable platform. Once you get an installation working, if you want to run it again a year from now, you don't need to worry overly about system updates, etc. It should just still work.
## You can do risky things. Again, if you do something really weird that breaks your system, you can just re-image the sd card. Be bold and audacious.
::